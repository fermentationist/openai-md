import "dotenv/config";
import * as url from "node:url";
import * as fs from "fs";
import CLISpinner from "./spinner.js";
import * as openAi from "./openAi.js";

export const getCompletion = openAi.getCompletion;
export const getModeration = openAi.getModeration;
export const failsModeration = openAi.failsModeration;

// get environment variables
const OUTPUT_DIRECTORY = process.env.NBPG_OUTPUT_DIRECTORY || "temp";
const AUTHOR = process.env.NBPG_AUTHOR;

let tempDirExists: boolean | null = null;

// instantiate CLISpinner
const spinner = new CLISpinner();

// getMarkdownPrompt returns a string to be used as a prompt for the OpenAI API
function getMarkdownPrompt(
  userPrompt: string,
  frontMatterToGenerate: string[] = []
) {
  const frontMatterToGenerateCopy = [...frontMatterToGenerate];
  const lastKey = frontMatterToGenerateCopy.pop();
  // if there is only one key, we don't need to use the word "and"
  const frontMatterDescription = frontMatterToGenerateCopy.length
    ? `${frontMatterToGenerateCopy.join(", ")}${
        lastKey ? ` and ${lastKey}` : ""
      }`
    : `${lastKey ?? ""}`;
  // if there is no front matter to generate, don't include the front matter part of the prompt
  const prompt = `Write a markdown file that includes ${
    frontMatterDescription
      ? `front matter with ${frontMatterDescription}, and `
      : ``
  }content that uses a single main heading and section headings, lists and code blocks where appropriate in response to the following prompt: {${userPrompt}}`;
  return prompt;
}

// getMarkdownContent returns a string containing a blog post generated by the OpenAI API, in markdown format
async function getMarkdownContent(
  prompt: string,
  temperature?: number,
  maxTokens?: number
) {
  console.log("Generating markdown content. This may take a minute...");
  spinner.start();
  const completion = await openAi.getCompletion(prompt, temperature, maxTokens);
  spinner.stop();
  return completion as string;
}

// writeToFile writes the data to a markdown file on disk
function writeToFile(dirName: string, filename: string, data: string) {
  if (tempDirExists === null) {
    // have not yet checked if directory exists
    tempDirExists = fs.existsSync(dirName);
  }
  if (!tempDirExists) {
    fs.mkdirSync(dirName);
  }
  return fs.writeFileSync(`${dirName}/${filename}.md`, data, "utf8");
}

// containsFrontMatter returns true if the markdown string contains front matter (meta) data
function containsFrontMatter(markdownString: string) {
  return (
    markdownString.trim().startsWith("---") &&
    (markdownString.match(/---/g) || []).length >= 2
  );
}

// parseMarkdown parses a string representation of a markdown file into a front matter (meta) object and a content string
function parseMarkdown(markdownString: string) {
  if (!containsFrontMatter(markdownString)) {
    return { meta: {}, content: markdownString };
  }
  const [_, frontMatter, ...contentArray] = markdownString.split("---");
  const content = contentArray.join("---");
  const keyValues = frontMatter?.split("\n");
  const frontMatterObject = (keyValues || []).reduce(
    (output, keyValueString) => {
      const [key, value] = keyValueString.split(": ");
      if (key.trim()) {
        output[key.trim()] = value?.trim();
      }
      return output;
    },
    {} as Record<string, string>
  );
  return { meta: frontMatterObject, content };
}

// slugify returns a slug for use in a URL and as a filename
function slugify(inputString: string) {
  const slug = inputString
    ?.trim()
    .toLowerCase()
    .replace(/[?"'“”‘’\.,/\[\]\{\}=\+\(\)\*\^%\$#@!]/g, "")
    .replaceAll("&", "and")
    .replaceAll(" ", "-");
  return encodeURIComponent(slug);
}

// getFilename returns a filename for a markdown file. It will based on a value in the front matter ("title", by default), or else the current date
function getFilename(markdownString: string, frontMatterKey = "title") {
  const { meta } = parseMarkdown(markdownString);
  return slugify(meta[frontMatterKey] ?? getDateString());
}

// frontMatterObjectToString returns a string representation of an object, to be used in a markdown file, as front matter
function frontMatterObjectToString(frontMatterObject: Record<string, string>) {
  const entries = Object.entries(frontMatterObject);
  const outputArray = entries.map(entry => {
    return `${entry[0]}: ${entry[1]}`;
  });
  return outputArray.join("\n");
}

// getDateString returns a string representation of the current date
function getDateString() {
  const newDate = new Date();
  const year = newDate.getFullYear();
  const month = newDate.getMonth() + 1;
  const date = newDate.getDate();
  return `${year}-${month}-${date}`;
}

// updateFrontMatter returns a string representation of a markdown file, with updated front matter
function updateFrontMatter(
  markdownString: string,
  frontMatter: Record<string, string> = {},
  frontMatterToGenerate: string[] = []
) {
  let updatedMeta: Record<string, string> = {};
  let content = markdownString;
  if (containsFrontMatter(markdownString)) {
    let meta: Record<string, string> = {};
    ({ meta, content } = parseMarkdown(markdownString));
    // remove any front matter keys that we did not ask the AI to generate
    for (const key in meta) {
      if (!frontMatterToGenerate.includes(key)) {
        delete meta[key];
      }
    }
    const metaWithLowerCaseKeys = Object.keys(meta).reduce((output, key) => {
      output[key.toLowerCase()] = meta[key];
      return output;
    }, {} as Record<string, string>);
    updatedMeta = {
      ...metaWithLowerCaseKeys,
      ...frontMatter,
    };
  } else {
    updatedMeta = { ...frontMatter };
  }
  if (frontMatterToGenerate.includes("date")) {
    updatedMeta.date = getDateString();
  }

  if (
    AUTHOR &&
    !frontMatterToGenerate.includes("author") &&
    !frontMatter.author
  ) {
    updatedMeta.author = AUTHOR;
  }
  const updatedFrontMatter = frontMatterObjectToString(updatedMeta);
  return `---\n${updatedFrontMatter}\n---\n${content}`;
}

// generateMarkdown returns a string representation of a markdown file, generated by the OpenAI API
export async function generateMarkdown(
  userPrompt: string,
  {
    meta = {},
    temperature = 0.95,
    frontMatterToGenerate = [],
    maxTokens,
  }: {
    meta?: Record<string, string>;
    temperature?: number;
    frontMatterToGenerate?: string[];
    maxTokens?: number;
  } = {}
) {
  const prompt = getMarkdownPrompt(userPrompt, frontMatterToGenerate);
  const content = await getMarkdownContent(prompt, temperature, maxTokens);
  let output;
  if (!!frontMatterToGenerate.length || !!Object.keys(meta).length) {
    output = updateFrontMatter(content, meta, frontMatterToGenerate);
  } else {
    output = content;
  }
  return output;
}

// generateMarkdownAndSaveToFile calls generateMarkdown and then saves the result to a file
export async function generateMarkdownAndSaveToFile(
  userPrompt: string,
  {
    temperature, // the "temperature" to use when generating an OpenAI completion: a number between 0 and 2, defaults to 0.95
    meta, // an object containing the front matter to be added to the markdown file
    frontMatterToGenerate, // an array containing the keys for front matter values to be generated by the OpenAI API
    outputDirectory = OUTPUT_DIRECTORY, // the directory to save the file to, defaults to "temp"
    filenameKey, // the key in the front matter to use as the filename, defaults to "title",
    filename, // the filename to use, defaults to the value of filenameKey
    maxTokens, // the maximum number of tokens to generate, defaults to the difference between the maximum allowed (2048) and the estimated number of tokens in the prompt
    model, // the model to use, defaults to "davinci"
  }: {
    temperature?: number;
    meta?: Record<string, string>;
    frontMatterToGenerate?: string[];
    outputDirectory?: string;
    filenameKey?: string;
    filename?: string;
    maxTokens?: number;
    model?: string;
  } = {}
) {
  const markdownContent = await generateMarkdown(userPrompt, {
    meta,
    temperature,
    frontMatterToGenerate,
    maxTokens,
  });
  const nameOfFile = filename ?? getFilename(markdownContent, filenameKey);
  writeToFile(outputDirectory, nameOfFile, markdownContent);
  console.log("Markdown saved to:", `${outputDirectory}/${nameOfFile}.md`);
}

// if this file is run from the command line, call generateMarkdownAndSaveToFile
if (import.meta.url.startsWith("file:")) {
  const path = url.fileURLToPath(import.meta.url);
  const [_, modulePath, userPrompt, temperature, outputDirectory, filename] =
    process.argv;
  if (modulePath === path) {
    await generateMarkdownAndSaveToFile(userPrompt, {
      temperature: parseFloat(temperature),
      outputDirectory,
      filename,
    });
  }
}

#!/usr/bin/env node
import "dotenv/config";
import { createInterface } from "readline";
import { generateMarkdownAndSaveToFile } from "./index.js";
import yargs from "yargs/yargs";

const API_KEY = process.env.OPENAI_API_KEY;
const OUTPUT_DIRECTORY = process.env.OAIMD_OUTPUT_DIRECTORY || "temp";
const AUTHOR = process.env.OAIMD_AUTHOR;
let apiKey: string | undefined = void 0;
let meta: Record<string, string> = {};
const argv = await yargs(process.argv.slice(2)).options({
  prompt: { type: "string", alias: "p" },
  temperature: { type: "number", alias: "t" },
  outputDirectory: { type: "string", alias: "o" },
  filename: { type: "string", alias: "f" },
  apiKey: { type: "string", alias: "k" },
  author: { type: "string", alias: "a" },
  frontMatterToGenerate: { type: "string", alias: "g" },
  meta: { type: "string", alias: "m" },
}).argv;

let [
  promptPositional,
  temperaturePositional,
  outputDirectoryPositional,
  filenamePositional,
]: any[] = argv._;

const {
  prompt: userPromptFlag,
  temperature: temperatureFlag,
  outputDirectory: outputDirectoryFlag,
  filename: filenameFlag,
  apiKey: apiKeyFlag,
  author: authorFlag,
  frontMatterToGenerate: frontMatterToGenerateFlag,
  meta: metaFlag,
} = argv;

let userPrompt = userPromptFlag ?? promptPositional;
let temperature = temperatureFlag ?? temperaturePositional;
let outputDirectory = outputDirectoryFlag ?? outputDirectoryPositional;
let filename = filenameFlag ?? filenamePositional;
apiKey = apiKeyFlag ?? API_KEY;
let author = authorFlag;
let frontMatterToGenerate =
  frontMatterToGenerateFlag &&
  frontMatterToGenerateFlag
    .split(",")
    .map(item => item.trim())
    .filter(item => item);

console.log("\n\nWelcome to openai-md! (OpenAI API Markdown Generator)\n");

const main = async (): Promise<any> => {
  let readline: any = createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  let readlineAsync = (question: string) =>
    new Promise<string>(resolve => {
      return readline.question(question, (answer: string) => resolve(answer));
    });

  while (!userPrompt) {
    // if no prompt is provided, prompt the user for one
    userPrompt = await readlineAsync(`Prompt: `);
  }

  while (!apiKey) {
    // if no API key is found in the environment variables
    console.log(
      "No OpenAI API key found. Please enter one now, or set the OPEN_AI_API_KEY environment variable and retry."
    );
    // prompt the user for an API key
    apiKey = await readlineAsync("OpenAI API Key: ");
  }

  // prompt the user for the author name
  if (!authorFlag) {
    author =
      (await readlineAsync(`Author${AUTHOR ? `[${AUTHOR}]` : ""}: `)) || AUTHOR;
  }

  if (!frontMatterToGenerate) {
    // prompt the user for the front matter keys to be generated by the OpenAI API
    const frontMatterList = await readlineAsync(
      `Front matter keys to generate (comma-separated): `
    );
    frontMatterToGenerate = frontMatterList
      .split(",")
      .map(item => item.trim())
      .filter(item => item);
  }

  // prompt the user for meta data to be added to the front matter
  const metaData = !metaFlag
    ? await readlineAsync(
        `Meta data to be added to front matter directly (enter as JSON object): `
      )
    : metaFlag;

  if (metaData) {
    try {
      meta = JSON.parse(metaData || "{}");
    } catch (e) {
      console.log("Invalid JSON. Skipping.");
      meta = {};
    }
  }

  while (
    temperature === undefined ||
    temperature === "" ||
    isNaN(parseFloat(temperature)) ||
    parseFloat(temperature) < 0 ||
    parseFloat(temperature) > 2
  ) {
    // prompt the user for the temperature to use when generating an OpenAI completion
    temperature =
      (await readlineAsync(
        `Temperature (number between 0 and 2)${
          temperature !== undefined && temperature !== ""
            ? `[${temperature}]`
            : `[1.0]`
        }: `
      )) || "1.0";
  }

  // prompt the user for the output directory
  outputDirectory =
    outputDirectory ??
    ((await readlineAsync(
      `Output directory${OUTPUT_DIRECTORY ? `[${OUTPUT_DIRECTORY}]` : ""}: `
    )) ||
      OUTPUT_DIRECTORY);

  if (filename === undefined || filename === "") { // if no filename is provided
    // prompt the user for the filename
    let filenameQuery = `Filename [default: use current date]: `;
    if (frontMatterToGenerate.includes("title") || "title" in meta) {
      filenameQuery = `Filename [default: use title]: `;
    } else if (frontMatterToGenerate.includes("date") || "date" in meta) {
      filenameQuery = `Filename [default: use date]: `;
    }
    filename = (await readlineAsync(filenameQuery));
  }

  if (filename?.endsWith(".md")) {
    filename = filename.slice(0, -3);
  }

  if (author) {
    meta.author = author;
  }

  await generateMarkdownAndSaveToFile(userPrompt, {
    temperature: parseFloat(temperature),
    outputDirectory,
    frontMatterToGenerate,
    filename,
    meta: meta as Record<string, string>,
    apiKey,
  });

  const again = await readlineAsync("Generate another file? [y/n]: ");
  if (["y", "yes"].includes(again.toLowerCase())) {
    filename = void 0;
    temperature = void 0;
    outputDirectory = void 0;
    userPrompt = void 0;
    frontMatterToGenerate = void 0;
    author = void 0;
    readline.close();
    return main();
  }
  process.exit(0);
};

main();
